"use strict";

var utils = require('app/utils'),
     playersModule = require('app/players');

class Weapon {
    constructor(weaponData) {
        this.name = weaponData.name;
        this.minDamage = weaponData.minDamage;
        this.maxDamage = weaponData.maxDamage;
        this.accuracy = weaponData.accuracy;
        this.reloadingTime = weaponData.reloadingTime;
        this.lastShotTime = 0;
        this.ammo = weaponData.ammo;
    }

    isCanShot() {
        return this.ammo && Date.now() - this.lastShotTime > this.reloadingTime * 1000;
    }
    shot() {
        if(this.isCanShot()) {
            this.lastShotTime = Date.now();
            this.ammo -= 1;
            return true;
        } else {
            return false;
        }
    }

    getDamage(damageMultiplier) {
        return Math.trunc(utils.random(this.maxDamage, this.minDamage) * (damageMultiplier || 1));
    }
}

class MultiTargetWeapon extends Weapon {
    constructor(weaponData) {
        super(weaponData);
        this.targetsCount = weaponData.targetsCount;
    }

    getDamagePenalty(targetRange, furtherTargetRange) {
        return 1;
    }
    shot(mainTarget, targetArray) {
        var results = [];
        if(!super.shot()) {
            return [];
        }
        targetArray.sort(function(a, b) {
            var aDistance = utils.getDistanceBetweenCoords(a.lng, a.lat, mainTarget.lng, mainTarget.lat),
                bDistance = utils.getDistanceBetweenCoords(b.lng, b.lat, mainTarget.lng, mainTarget.lat);
            return aDistance - bDistance;
        });
        for(var i = 0; i < this.targetsCount; i++) {
            var target = targetArray[i],
                furtherTarget = targetArray[this.targetsCount - 1],
                targetRange = utils.getDistanceBetweenCoords(mainTarget.lng, mainTarget.lat, target.lng, target.lat),
                furtherTargetRange = utils.getDistanceBetweenCoords(mainTarget.lng, mainTarget.lat, furtherTarget.lng, furtherTarget.lat),
                penalty = this.getDamagePenalty(targetRange, furtherTargetRange);
            results.push(target.processDamage(this.getDamage(penalty)));
        };
        return results;
    }
}

class Pistol extends Weapon {
    constructor() {
        super({
            name: 'pistol',
            minDamage: 10,
            maxDamage: 20,
            accuracy: 1,
            reloadingTime: 5,
            ammo: 'Inf'
        });
    }

    shot(target) {
        return super.shot() ? [target.processDamage(this.getDamage())] : [];
    }
}

class Machinegun extends MultiTargetWeapon {
    constructor() {
        super({
            name: 'machinegun',
            minDamage: 30,
            maxDamage: 40,
            accuracy: 0.5,
            reloadingTime: 7,
            ammo: 40,
            targetsCount: 5
        });
    }
}

class Shotgun extends MultiTargetWeapon {
    constructor() {
        super({
            name: 'shotgun',
            minDamage: 60,
            maxDamage: 70,
            accuracy: 0.9,
            reloadingTime: 15,
            ammo: 20,
            targetsCount: 2
        });
    }
}

class RocketLauncher extends MultiTargetWeapon {
    constructor() {
        super({
            name: 'rocketlauncher',
            minDamage: 60,
            maxDamage: 70,
            accuracy: 1,
            reloadingTime: 30,
            ammo: 3,
            targetsCount: 10
        });
    }

    getDamagePenalty(targetRange, furtherTargetRange) {
        return 1 - (0.5 * targetRange / furtherTargetRange);
    }
}

module.exports = {
    weaponsList: [new Pistol(), new Machinegun(), new Shotgun(), new RocketLauncher()],

    getDefaultWeapon: function() {
        return this.weaponsList[0];
    },
    getWeaponList: function() {
        var pistol = new Pistol();
        return this.weaponsList.map(function(weapon) {
            weapon.lastShotTime = 0;
            return weapon;
        });
    },
};

