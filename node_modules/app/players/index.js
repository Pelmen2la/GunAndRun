"use strict";

var weaponsModule = require('app/weapons'),
    fs = require('fs'),
    path = require('path'),
    utils = require('app/utils');

function generateGUID() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
}

class Player {
    constructor(playerData) {
        this.name = playerData.name;
        this.key = generateGUID();
        this.weaponList = weaponsModule.getWeaponList();
        this.hp = 100;
        this.lastDeathTime = 0;
        this.country = playerData.country;
        this.town = playerData.town;
        this.lastRequestTime = Date.now();
        this.isBot = playerData.isBot;
        this.lat = playerData.lat || playerData.country.latlng[0] + utils.random(-5, 5);
        this.lng = playerData.lon || playerData.country.latlng[1] + utils.random(-5, 5);
        this.actionList = [];
    }

    getCoords() {
        return [this.lng, this.lat];
    }
    processDamage(damage) {
        var isKill = false;
        if(this.isImmune()) {
            damage: 0;
        } else {
            this.hp -= damage;
            if(this.hp <= 0) {
                isKill = true;
                this.lastDeathTime = Date.now();
                this.hp = 100;
            }
        }
        return {
            damage: damage,
            isKill: isKill
        }
    }
    getWeaponByName(selectedWeaponName) {
        return this.getWeapon(selectedWeaponName)
    }
    isImmune() {
        return Date.now() - this.lastDeathTime < 15 * 1000;
    }
    getWeapon(weaponName) {
        return this.weaponList.find(function(weapon) {
            return weapon.name === weaponName;
        });
    }
}

module.exports = {
    playersHash: {},
    bots: [],
    getPlayersArray: function(excludedNames) {
        var res = [];
        utils.forEachKeyInDict(this.playersHash,function(player) {
            if(excludedNames && excludedNames.indexOf(player.name) === -1) {
                res.push(player);
            }
        });
        return res;
    },
    isPlayersExists: function(name) {
        return !!this.playersHash[name];
    },
    tryAddPlayer: function(playerData) {
        if(this.isPlayersExists(playerData.name)) {
            return {
                success: false
            }
        }
        return {
            success: true,
            playerData: this.addPlayer(playerData)
        }
    },
    addPlayer: function(playerData) {
        if(!playerData.country) {
            playerData.country = this.getNoneCountry();
        }
        var player = new Player(playerData);
        this.playersHash[player.name] = player;
        if(this.bots.length === 0) {
            this.addBots();
        }
        return player;
    },
    deletePlayer: function(name) {
        delete players[name]
    },
    getNoneCountry: function(country) {
        return {
            demonym: 'Unknown',
            latlng: [utils.random(65), utils.random(180)],
            name: {
                common: 'Unknown'
            }
        }
    },
    addBots: function() {
        var me = this;
        fs.readFile(path.join(__dirname, 'randomnicknames.txt'), function(err, data) {
            var names = data.toString().split("\r\n");
            for(var i = 0; i < 10; i++) {
                var name = utils.getRandomArrayEntry(names, true);
                me.addBot(name);
            }
        });
    },
    addBot: function(name) {
        var me = this;
        utils.getCountryList(function(countryList) {
            var bot = me.tryAddPlayer({
                name: name,
                country: utils.getRandomArrayEntry(countryList),
                isBot: true
            }, true);
            if(bot.success) {
                me.bots.push(bot.playerData);
            }
        });
    }
};

